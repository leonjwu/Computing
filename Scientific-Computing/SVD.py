import numpy as np
import matplotlib.pyplot as plt


def reduce(H, inputs=(12, 69, 12), display=False):
    """
    Construct one or more arrays from H
    that can be used by reconstruct
    Input:
        H: 3-D data array
        inputs: can be used to provide other input as needed
    Output:
        arrays: a tuple containing the arrays produced from H
    """
    M, N, T = H.shape

    if not display:
        p, q, r = inputs

    # Compute p if display
    if display:
        xm, xn, xt = plot_SVD3(H)
        # print(f'xm, xn, xt = {xm}, {xn}, {xt}')
        p = xm #12
    print(f'p={p}')

    # Reduce H, slicing in first dimension
    K = min(N, T)
    UM = np.zeros((M, N, K))
    SM = np.zeros((M, K))
    VhM = np.zeros((M, K, T))
    # Compute SVD for each slice
    for i in range(M):
        UM[i,:,:], SM[i,:], VhM[i,:,:] = np.linalg.svd(H[i,:,:], full_matrices=False)
    # Keep only relevant portions of arrays
    UM = UM[:,:,:p]
    SM = SM[:,:p]
    VhM = VhM[:,:p,:]

    # Reduce UM, slicing in p dimension
    if display:
        x1, x2, x3 = plot_SVD3(UM)
        # print(f'x1, x2, x3 = {x1}, {x2}, {x3}')
        q = x3 #69
    print(f'q={q}')
    K = min(M, N)
    UMU = np.zeros((p, M, K))
    UMS = np.zeros((p, K))
    UMVh = np.zeros((p, K, N))
    # Compute SVD for each slice
    print(UM.shape)
    for i in range(p):
        UMU[i,:,:], UMS[i,:], UMVh[i,:,:] = np.linalg.svd(UM[:,:,i], full_matrices=False)
    # Keep only relevant portions of arrays
    UMU = UMU[:,:,:q]
    UMS = UMS[:,:q]
    UMVh = UMVh[:,:q,:]

    # Reduce VhM, slicing in p dimension
    if display:
        x1, x2, x3 = plot_SVD3(VhM)
        # print(f'x1, x2, x3 = {x1}, {x2}, {x3}')
        r = x2 #12
    print(f'r={r}')
    K = min(M, T)
    VhMU = np.zeros((p, M, K))
    VhMS = np.zeros((p, K))
    VhMVh = np.zeros((p, K, T))
    # Compute SVD for each slice
    for i in range(p):
        VhMU[i,:,:], VhMS[i,:], VhMVh[i,:,:] = np.linalg.svd(VhM[:,i,:], full_matrices=False)
    # Keep only relevant portions of arrays
    VhMU = VhMU[:,:,:r]
    VhMS = VhMS[:,:r]
    VhMVh = VhMVh[:,:r,:]

    if display:
        print("Original Shape:")
        print(H.shape)
        a = H.size
        print(a)
        print("New Shapes:")
        print(UMU.shape, UMS.shape, UMVh.shape, VhMU.shape, VhMS.shape, VhMVh.shape, SM.shape)
        b = np.sum((UMU.size, UMS.size, UMVh.size, VhMU.size, VhMS.size, VhMVh.size, SM.size))
        print(b)
        print("Size of output compared to input:")
        print(f'{round(100*b/a, 3)}%')

    arrays = (UMU, UMS, UMVh, VhMU, VhMS, VhMVh, SM)
    return arrays


def reconstruct(arrays,inputs=()):
    """
    Generate matrix with same shape as H (see reduce above)
    that has some meaningful correspondence to H
    Input:
        arrays: tuple generated by reduce
        inputs: can be used to provide other input as needed
    Output:
        Hnew: a numpy array with the same shape as H
    """
    # Get arrays from reduce function
    UMU, UMS, UMVh, VhMU, VhMS, VhMVh, SM = arrays
    p, M, q = UMU.shape
    N = UMVh.shape[2]
    T = VhMVh.shape[2]

    # Construct UM
    UM = np.zeros((M, N, p))
    for i in range(p):
        UM[:,:,i] = np.matmul(UMU[i,:,:], np.matmul(np.diag(UMS[i,:]), UMVh[i,:,:]))

    # Construct Vh
    VhM = np.zeros((M, p, T))
    for i in range(p):
        VhM[:,i,:] = np.matmul(VhMU[i,:,:], np.matmul(np.diag(VhMS[i,:]), VhMVh[i,:,:]))

    # Construct H
    Hnew = np.zeros((M,N,T))
    for i in range(M):
        Hnew[i,:,:] = np.matmul(UM[i,:,:], np.matmul(np.diag(SM[i,:]), VhM[i,:,:]))

    return Hnew


if __name__=='__main__':
    #reduce(X)
